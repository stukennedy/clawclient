package templates

import (
	"fmt"
	"clawclient/internal/ctxengine"
)

// HomePage renders the main timeline view.
templ HomePage() {
	@AppShell("ClawClient", false) {
		<div id="main-view" class="h-full flex flex-col"
			data-init="@get('/api/timeline')">
			@TimelineLoading()
		</div>
	}
}

// TimelineLoading shows a loading state.
templ TimelineLoading() {
	<div id="timeline-content" class="flex flex-col items-center justify-center py-20">
		<div class="w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
		<p class="text-zinc-400 text-sm">Loading timeline...</p>
	</div>
}

// TimelineEmpty shows when there's no data.
templ TimelineEmpty() {
	<div id="timeline-content" class="flex flex-col items-center justify-center py-20">
		<span class="text-4xl mb-4">ü¶û</span>
		<h2 class="text-lg font-semibold text-zinc-300 mb-2">No conversations yet</h2>
		<p class="text-zinc-500 text-sm">Send a message to get started</p>
	</div>
}

// TimelineView renders the full timeline (inner content only).
templ TimelineView(blocks []ctxengine.TimelineBlock) {
	<div id="timeline-content" class="space-y-2">
		if len(blocks) == 0 {
			@TimelineEmpty()
		}
		for i, block := range blocks {
			if i == 0 || blocks[i-1].Date != block.Date {
				@DateHeader(block.Date)
			}
			@ContextBlock(block)
		}
	</div>
}

// FeedView renders the unified feed ‚Äî all messages chronologically with context colors.
templ FeedView(feed []ctxengine.FeedMessage) {
	<div id="main-view" class="flex flex-col h-full"
		data-signals="{activeThread: ''}">
		<div class="flex-1 overflow-y-auto px-4 py-4">
			<div id="message-list" class="space-y-3 max-w-4xl mx-auto">
				if len(feed) > 0 {
					<!-- Load earlier messages button -->
					<div class="flex justify-center py-2">
						<button
							data-on:click="@get('/api/loadmore')"
							class="text-xs text-zinc-500 hover:text-zinc-300 bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 rounded-full px-4 py-1.5 transition-colors"
						>
							‚Üë Load earlier messages
						</button>
					</div>
				}
				if len(feed) == 0 {
					@TimelineEmpty()
				}
				for _, msg := range feed {
					@FeedBubble(msg)
				}
			</div>
		</div>
		<script>
			requestAnimationFrame(function() {
				var container = document.querySelector('.overflow-y-auto');
				if (container) container.scrollTop = container.scrollHeight;
			});
		</script>
	</div>
}

// FeedBubble renders a single message in the feed with a context color indicator.
templ FeedBubble(msg ctxengine.FeedMessage) {
	if msg.Event.Role == "user" {
		<div id={ "msg-" + msg.Event.ID } class="flex justify-end">
			<div class="max-w-[80%]">
				<div class="bg-blue-600 text-white rounded-2xl rounded-br-md px-4 py-2.5"
					style={ fmt.Sprintf("border-left: 3px solid %s", msg.ContextColor) }>
					<p class="text-sm leading-relaxed whitespace-pre-wrap">{ msg.Event.Content }</p>
					<div class="flex items-center justify-end gap-2 mt-1">
						<button
							data-on:click={ fmt.Sprintf("@get('/api/thread/%s')", msg.ContextKey) }
							class="text-[10px] text-blue-200 hover:text-white transition-colors flex items-center gap-1"
							style={ fmt.Sprintf("border-bottom: 1px solid %s", msg.ContextColor) }
						>
							<span class="w-1.5 h-1.5 rounded-full inline-block" style={ fmt.Sprintf("background: %s", msg.ContextColor) }></span>
							{ msg.ContextName }
						</button>
						if !msg.Event.Timestamp.IsZero() {
							<span class="text-[10px] text-blue-200">{ msg.Event.Timestamp.Format("15:04") }</span>
						}
					</div>
				</div>
			</div>
		</div>
	} else {
		<div id={ "msg-" + msg.Event.ID } class="flex justify-start">
			<div class="max-w-[80%]">
				<div class="bg-zinc-800 border border-zinc-700 text-zinc-200 rounded-2xl rounded-bl-md px-4 py-2.5"
					style={ fmt.Sprintf("border-left: 3px solid %s", msg.ContextColor) }>
					if msg.Event.Model != "" {
						<span class="text-[10px] text-zinc-500 block mb-1">{ msg.Event.Model }</span>
					}
					<p class="text-sm leading-relaxed whitespace-pre-wrap">{ msg.Event.Content }</p>
					<div class="flex items-center gap-2 mt-1">
						<button
							data-on:click={ fmt.Sprintf("@get('/api/thread/%s')", msg.ContextKey) }
							class="text-[10px] text-zinc-500 hover:text-zinc-300 transition-colors flex items-center gap-1"
							style={ fmt.Sprintf("border-bottom: 1px solid %s", msg.ContextColor) }
						>
							<span class="w-1.5 h-1.5 rounded-full inline-block" style={ fmt.Sprintf("background: %s", msg.ContextColor) }></span>
							{ msg.ContextName }
						</button>
						if !msg.Event.Timestamp.IsZero() {
							<span class="text-[10px] text-zinc-500">{ msg.Event.Timestamp.Format("15:04") }</span>
						}
					</div>
				</div>
			</div>
		</div>
	}
}

// TimelineBlocks renders the old block-based timeline (kept for fallback).
templ TimelineBlocks(blocks []ctxengine.TimelineBlock) {
	<div id="main-view" class="max-w-4xl mx-auto p-4"
		data-signals="{activeThread: ''}">
		<div class="space-y-2">
			if len(blocks) == 0 {
				@TimelineEmpty()
			}
			for i, block := range blocks {
				if i == 0 || blocks[i-1].Date != block.Date {
					@DateHeader(block.Date)
				}
				@ContextBlock(block)
			}
		</div>
	</div>
}

// DateHeader renders a date divider.
templ DateHeader(date string) {
	<div class="flex items-center gap-3 py-3">
		<div class="h-px flex-1 bg-zinc-700"></div>
		<span class="text-xs font-medium text-zinc-500 uppercase tracking-wider">{ date }</span>
		<div class="h-px flex-1 bg-zinc-700"></div>
	</div>
}

// ContextBlock renders a single context block on the timeline.
templ ContextBlock(block ctxengine.TimelineBlock) {
	<div
		class="bg-zinc-800 rounded-lg border border-zinc-700 hover:border-zinc-600 transition-colors cursor-pointer overflow-hidden"
		style={ fmt.Sprintf("border-left: 4px solid %s", block.Context.Color) }
		data-on:click={ fmt.Sprintf("@get('/api/thread/%s')", block.Context.Name) }
	>
		<div class="px-4 py-3">
			<div class="flex items-center justify-between mb-1">
				<h3 class="font-medium text-zinc-200 text-sm">{ block.Context.Name }</h3>
				<span class="text-xs text-zinc-500">
					if !block.Context.LastEvent.IsZero() {
						{ block.Context.LastEvent.Format("15:04") }
					}
				</span>
			</div>
			if block.Preview != "" {
				<p class="text-zinc-400 text-sm leading-relaxed line-clamp-2">{ block.Preview }</p>
			}
			if len(block.AgentBadges) > 0 {
				<div class="flex flex-wrap gap-1.5 mt-2">
					for _, agent := range block.AgentBadges {
						@AgentBadge(agent)
					}
				</div>
			}
			if block.HasCompaction {
				<div class="mt-2 flex items-center gap-1.5 text-xs text-zinc-500">
					<span>üì¶</span>
					<span>Compacted</span>
				</div>
			}
			if block.IsCron {
				<div class="mt-1 flex items-center gap-1.5 text-xs text-zinc-500">
					<span>‚è∞</span>
					<span>Scheduled</span>
				</div>
			}
		</div>
	</div>
}

// AgentBadge renders a sub-agent badge.
templ AgentBadge(agent ctxengine.AgentSpawn) {
	<span class="inline-flex items-center gap-1 text-xs bg-zinc-700 text-zinc-300 rounded-full px-2.5 py-0.5">
		<span>ü§ñ</span>
		if agent.Model != "" {
			<span class="text-zinc-400">{ agent.Model }:</span>
		}
		<span>{ agent.Task }</span>
		if agent.Status == "running" {
			<span class="w-1.5 h-1.5 rounded-full bg-amber-400 animate-pulse"></span>
		}
	</span>
}

// ThreadView renders just the thread content (inner content for #main-view).
templ ThreadView(thread *ctxengine.Context) {
	<div class="flex flex-col h-full">
		<!-- Thread Header -->
		<div class="flex items-center gap-3 px-4 py-3 bg-zinc-800 border-b border-zinc-700 shrink-0">
			<button
				data-on:click="@get('/api/timeline')"
				class="text-zinc-400 hover:text-zinc-200 transition-colors"
			>
				<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
					<path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"/>
				</svg>
			</button>
			<div class="w-3 h-3 rounded-full shrink-0" style={ fmt.Sprintf("background: %s", thread.Color) }></div>
			<h2 class="font-semibold text-zinc-200">{ thread.Name }</h2>
		</div>
		<!-- Thread Content -->
		<div class="flex-1 overflow-y-auto px-4 py-4 space-y-4">
			if thread.StatusMD != "" {
				@StatusCard(thread.StatusMD)
			}
			if thread.Agents != nil && len(thread.Agents) > 0 {
				<div class="flex flex-wrap gap-1.5 mb-3">
					for _, agent := range thread.Agents {
						@AgentBadge(agent)
					}
				</div>
			}
			<div id="message-list" class="space-y-3">
				for _, event := range thread.Events {
					if event.Type == "message" || event.Content != "" {
						<div id={ "msg-" + event.ID }>
							@MessageBubble(event)
						</div>
					}
					if event.Type == "compaction" {
						@CompactionDivider()
					}
				}
			</div>
		</div>
	</div>
}

// ThreadPage renders the thread view that replaces #main-view (for navigation).
templ ThreadPage(thread *ctxengine.Context) {
	<div id="main-view" class="flex flex-col h-full"
		data-signals={ fmt.Sprintf("{activeThread: '%s'}", thread.Name) }>
		@ThreadView(thread)
		<script>
			// Auto-scroll to bottom of thread
			requestAnimationFrame(function() {
				var container = document.querySelector('.overflow-y-auto');
				if (container) container.scrollTop = container.scrollHeight;
			});
		</script>
	</div>
}

// StatusCard renders STATUS.md content as a pinned card.
templ StatusCard(content string) {
	<div class="bg-zinc-800 border border-zinc-700 rounded-lg p-4 mb-4">
		<div class="flex items-center gap-2 mb-2">
			<span class="text-sm">üìå</span>
			<span class="text-xs font-medium text-zinc-400 uppercase tracking-wider">Status</span>
		</div>
		<div class="text-sm text-zinc-300 leading-relaxed prose prose-invert prose-sm max-w-none">
			{ content }
		</div>
	</div>
}

// MessageBubble renders a single message.
templ MessageBubble(event ctxengine.Event) {
	if event.Role == "user" {
		<div class="flex justify-end">
			<div class="max-w-[80%] bg-blue-600 text-white rounded-2xl rounded-br-md px-4 py-2.5">
				<p class="text-sm leading-relaxed whitespace-pre-wrap">{ event.Content }</p>
				<span class="text-[10px] text-blue-200 mt-1 block text-right">
					if !event.Timestamp.IsZero() {
						{ event.Timestamp.Format("15:04") }
					}
				</span>
			</div>
		</div>
	} else {
		<div class="flex justify-start">
			<div class="max-w-[80%] bg-zinc-800 border border-zinc-700 text-zinc-200 rounded-2xl rounded-bl-md px-4 py-2.5">
				if event.Model != "" {
					<span class="text-[10px] text-zinc-500 block mb-1">{ event.Model }</span>
				}
				<p class="text-sm leading-relaxed whitespace-pre-wrap">{ event.Content }</p>
				<span class="text-[10px] text-zinc-500 mt-1 block">
					if !event.Timestamp.IsZero() {
						{ event.Timestamp.Format("15:04") }
					}
				</span>
			</div>
		</div>
	}
}

// CompactionDivider renders a compaction separator.
templ CompactionDivider() {
	<div class="flex items-center gap-2 py-2">
		<div class="h-px flex-1 bg-zinc-700 opacity-50"></div>
		<span class="text-[10px] text-zinc-600 flex items-center gap-1">
			<span>üì¶</span> compacted
		</span>
		<div class="h-px flex-1 bg-zinc-700 opacity-50"></div>
	</div>
}

// ContextList renders the context list for the dropdown menu.
templ ContextList(contexts []*ctxengine.Context) {
	<div id="context-list">
		if len(contexts) == 0 {
			<p class="text-zinc-500 text-xs text-center py-4">No contexts yet</p>
		}
		for _, ctx := range contexts {
			<button
				onclick="document.getElementById('ctx-menu').classList.add('hidden')"
				data-on:click={ fmt.Sprintf("@get('/api/thread/%s')", ctx.Name) }
				class="w-full text-left px-5 py-3.5 hover:bg-zinc-700/50 transition-colors flex items-center gap-3 border-b border-zinc-700/30"
			>
				<span class="w-2.5 h-2.5 rounded-full shrink-0" style={ fmt.Sprintf("background: %s", ctx.Color) }></span>
				<div class="flex-1 min-w-0">
					<div class="flex items-center justify-between">
						<span class="text-sm font-medium text-zinc-200 truncate">{ ctx.Name }</span>
						if !ctx.LastEvent.IsZero() {
							<span class="text-[10px] text-zinc-500 shrink-0 ml-2">{ ctx.LastEvent.Format("15:04") }</span>
						}
					</div>
					if ctx.Summary != "" {
						<p class="text-xs text-zinc-500 truncate mt-0.5">{ ctx.Summary }</p>
					}
				</div>
			</button>
		}
	</div>
}

// OnboardPage renders the setup screen.
templ OnboardPage(defaultGatewayURL string) {
	@Layout("ClawClient - Setup") {
		<div class="min-h-screen flex items-center justify-center p-4">
			<div class="w-full max-w-md"
				data-signals={ fmt.Sprintf("{gatewayUrl: '%s', authToken: '', connectStatus: '', connectError: ''}", defaultGatewayURL) }>
				<div class="text-center mb-8">
					<span class="text-5xl block mb-4">ü¶û</span>
					<h1 class="text-2xl font-bold text-zinc-100 mb-2">ClawClient</h1>
					<p class="text-zinc-400 text-sm">Connect to your OpenClaw Gateway</p>
				</div>
				<div class="bg-zinc-800 rounded-xl border border-zinc-700 p-6 space-y-4">
					<div>
						<label class="block text-sm font-medium text-zinc-300 mb-1.5">Gateway URL</label>
						<input
							type="text"
							data-bind="gatewayUrl"
							placeholder="ws://localhost:18789"
							class="w-full bg-zinc-700 text-zinc-100 rounded-lg px-4 py-2.5 placeholder-zinc-500 border border-zinc-600 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors"
						/>
					</div>
					<div>
						<label class="block text-sm font-medium text-zinc-300 mb-1.5">Auth Token</label>
						<input
							type="password"
							data-bind="authToken"
							placeholder="Enter your auth token"
							class="w-full bg-zinc-700 text-zinc-100 rounded-lg px-4 py-2.5 placeholder-zinc-500 border border-zinc-600 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 transition-colors"
						/>
					</div>
					<button
						data-on:click="@post('/api/connect')"
						class="w-full bg-blue-600 hover:bg-blue-500 text-white rounded-lg px-4 py-3 font-medium transition-colors mt-2"
					>
						Connect
					</button>
					<div id="connect-feedback"></div>
				</div>
			</div>
		</div>
	}
}

// ConnectSuccess renders a success message after connecting.
templ ConnectSuccess() {
	<div id="connect-feedback" class="mt-4 bg-emerald-900/30 border border-emerald-700 rounded-lg p-3 text-center">
		<span class="text-emerald-400 text-sm">‚úÖ Connected successfully!</span>
	</div>
}

// ConnectError renders an error message.
templ ConnectError(msg string) {
	<div id="connect-feedback" class="mt-4 bg-red-900/30 border border-red-700 rounded-lg p-3 text-center">
		<span class="text-red-400 text-sm">‚ùå { msg }</span>
	</div>
}

// ConnectLoading renders a connecting state.
templ ConnectLoading() {
	<div id="connect-feedback" class="mt-4 bg-zinc-700/50 rounded-lg p-3 text-center flex items-center justify-center gap-2">
		<div class="w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
		<span class="text-zinc-400 text-sm">Connecting...</span>
	</div>
}

// StreamingMessage renders a message being streamed from an agent.
// Uses a stable id so Datastar can patch just this element during streaming.
templ StreamingMessage(id string, content string) {
	<div id={ "msg-" + id } class="flex justify-start">
		<div class="max-w-[80%] bg-zinc-800 border border-zinc-700 text-zinc-200 rounded-2xl rounded-bl-md px-4 py-2.5">
			<div class="flex items-center gap-2 mb-1">
				<div class="w-2 h-2 rounded-full bg-blue-400 animate-pulse"></div>
				<span class="text-[10px] text-zinc-500">Streaming...</span>
			</div>
			<p class="text-sm leading-relaxed whitespace-pre-wrap">{ content }</p>
		</div>
	</div>
}

// FinalMessage renders a completed assistant message that replaces the streaming one.
templ FinalMessage(id string, event ctxengine.Event) {
	<div id={ "msg-" + id }>
		@MessageBubble(event)
	</div>
}
